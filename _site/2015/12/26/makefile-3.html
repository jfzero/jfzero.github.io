<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="keywords" content="Makefile">
  
  
    <meta name="description" content="规则包括两个部分：一是依赖关系，二是生成目标的方法。">
  
  <meta name="author" content="terminal">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="baidu-site-verification" content="u8YJqmJmcq" />

  <link type="application/atom+xml" rel="alternate" href="http://terminalworld.github.io/feed.xml" title="terminalworld" />
  <link rel="shortcut icon" href="/assets/img/favicon.png">
  <link rel="stylesheet" href="/assets/lib/bootstrap/3.2.0/css/bootstrap.min.css">
  <link rel="stylesheet" href="/assets/lib/font-awesome/4.2.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="/assets/lib/jQCloud/jqcloud.css">
  <link rel="stylesheet" href="/assets/css/sticky-footer-navbar.css">
  <link rel="stylesheet" href="/assets/css/main.css">

  <script src="/assets/lib/jquery/jquery-2.0.3.min.js"></script>

  <title>三、书写规则</title>
</head>

<body>
<!-- Wrap all page content here -->
<div id="wrap">
  <!-- Navbar -->
  <div class="navbar navbar-default navbar-inverse global-nav">
    <div class="container-fluid">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">Terminalworld</a>
      </div>
      <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav pull-right">
          <li id="archive"><a href="/date.html">归档</a></li>
          <li id="timeline"><a href="/timeline.html">印迹</a></li>
          <li id="about"><a href="/about.html">关于</a></li>

<!--
          <li id="timeline"><a href="/timeline.html">Timeline</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">More <span class="caret"></span></a>
            <ul class="dropdown-menu">
              <li id="about"><a href="/about.html">About</a></li>
              <li id="album"><a href="/album.html">Album</a></li>
            </ul>
          </li>

        </ul>
        <ul class="nav navbar-nav pull-right">
          <form class="navbar-form navbar-right" role="search" action="http://google.com/search" method="get">
            <input type="hidden" name="q" value="site:terminalworld.github.io">
            <input type="text" class="form-control input-sm" placeholder="Search..." name="q">
          </form>
        </ul>

-->        

      </div>
      <!--/.nav-collapse -->
    </div>
  </div>
  <!-- Begin page content -->
  <div id="main-content">
    <style>
.headerbar{
  background: white;
  border-bottom: 2px solid #eaeaeb;
}
.headerbar .page-header{
  border-bottom: 0;
  margin-bottom: 0px;
  margin-top: 0px;
}
#page-content{
  margin-bottom: 15px;
}
@media (max-width: 768px){
  .header{
    font-size: 18px;
    line-height: 20px;
  }
  .meta{
    display: none;
  }
}
</style>

<div class="headerbar">
  <div class="page-header container-fluid">
    <h3 class="header">
      三、书写规则 <small>GNU Make读书笔记</small>
    </h3>
    <div class="meta">
        <div class="pull-left">
            

<span class="label label-blue" style="margin-right: 10px;">
    <span class="glyphicon glyphicon-folder-open"></span>
    <a href="/category.html#category-makefile"> Makefile</a>
</span>


            

<span class="label label-yellow" style="margin-right: 10px;">
    <span class="glyphicon glyphicon-tag"></span>
    <a href="/tag.html#tag-Makefile">Makefile</a>
</span>


        </div>
        <div class="pull-right text-muted">
            <span class="widget-date">

  <a data-post-date="2015-12-26"
     href="/date.html#date-2015-12" >
    <i class="glyphicon glyphicon-time"></i>
    2015-12-26
  </a>
</span>

        </div>
    </div>
  </div>
</div>

<div class="container-fluid">
  <div id="page-content">
    <link rel="stylesheet" href="/assets/css/markdown.css">
<link rel="stylesheet" href="/assets/css/vs-syntax.css">
<style>
  .sidebar {
    width: 200px;
    margin-top: 20px;
    border: 1px solid #eaeaeb;
  }

  .sidebar ul {
    margin-top: 0;
    margin-bottom: 0;
  }

  .sidebar.affix {
    position: fixed;
    top: 0;
  }

  .sidebar.affix-bottom {
    position: absolute;
  }

  .sidebar .nav{
    font-size: 13px;
  }
  .sidebar .nav .nav {
    display: none;
  }

  .sidebar .nav > .active > ul {
    display: block;
  }

  .sidebar .nav > li > a {
    display: block;
    padding: 5px 15px;
    color: #999;
    text-decoration: none;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .sidebar .nav .nav > li > a {
    padding-top: 3px;
    padding-bottom: 3px;
    margin-left: 10px;
    font-size: 90%;
  }

  .sidebar .nav .nav .nav > li > a {
    margin-left: 20px;
  }

  .sidebar .nav .nav .nav .nav > li > a {
    margin-left: 30px;
  }

  .sidebar .nav .nav .nav .nav .nav > li > a {
    margin-left: 40px;
  }

  .sidebar .nav .nav .nav .nav .nav .nav > li > a {
    margin-left: 50px;
  }

  .sidebar .nav > .active > a,
  .sidebar .nav > :hover > a{
    color: #333;
    text-decoration: none;
    border-right: 2px solid #f7565b;
  }
  .nav>li>a:hover, .nav>li>a:focus:hover {
    text-decoration: none;
    background-color: #f0f0f0;
  }
  .nav>li>a:focus{
    background-color: transparent;
  }
  .sidenav {
    margin-top: 20px;
    margin-bottom: 20px;
    background: #fff;
  }

  .MathJax * {
    color: black !important;
  }

  .md {
    margin-top: 20px;
    padding: 100px;
  }

  @media (max-width: 768px) {
    .md {
      padding: 20px 20px 40px;
    }
  }

  .copyright {
    font-size: 12px;
  }

  .copyright hr {
    margin: 45px 0 10px!important;
  }
</style>

<div class="row post-display">
  <div class="col-lg-2 col-md-3 col-sm-4 hidden-xs left">
    <div class="sidebar"></div>
  </div>
  <div class="col-lg-10 col-md-9 col-sm-8 right">
    <div class="md paper">
      <blockquote>
<p>规则包括两个部分：一是依赖关系，二是生成目标的方法。</p>
</blockquote>

<p>Makefile的规则是用来生成目标（target）的，它包括两部分：目标的依赖关系（prerequisites），
创建和更新目标所需要的命令（recipe）。</p>

<p>规则的顺序并不重要，但有一个例外，那就是Makefile的最终目标。
其他的目标都是由最终目标连带出来的，所以一定要知道最终目标。
最终目标只能有一个，默认是第一条规则的第一个目标。然而也有两个例外：</p>

<ol>
<li>目标以.开头，且后面跟的字符不是/（如.SECONDEXPANSION）。</li>
<li>模式匹配所定义的目标。</li>
</ol>

<p>这两种情况下的目标不会被当做最终目标。</p>

<h1>规则的语法</h1>

<p>一般是这样子的</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">targets </span><span class="o">:</span> <span class="n">prerequisites</span>
    recipe
    ...
</code></pre></div>
<p>或者这样</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">targets </span><span class="o">:</span> <span class="n">prerequisites</span> ; <span class="n">recipe</span>
    recipe
    ...
</code></pre></div>
<p>目标可以是文件名或者标签（clean），由空格隔开，并支持通配符。
目标文件一般只有一个，也有可能是多个文件。</p>

<p>recipe可以和target放在同一行，也可以放在不同行。同行时用<code>;</code>隔开，不同行时recipe需以<code>tab</code>键开头。</p>

<p><code>$</code>符号一般用来解析变量，可采用<code>$$</code>这种方式解析出一个<code>$</code>符号。
<code>\</code>符号用来做换行符。</p>

<p>书写规则告诉make两件事情：<strong>目标文件何时过时，以及如何更新目标文件。</strong></p>

<p>当目标文件不存在或者存在依赖文件比目标文件新时，目标被认为是&quot;过时的&quot;。make通过执行recipe来更新目标文件。
一般来说，make通过UNIX的标准shell，也就是/bin/sh来执行命令。</p>

<h1>依赖的类型</h1>

<p>prerequisites分为两种类型。一种是我们上面所说的常规依赖，当依赖文件比目标文件新时，目标被认为是过时的。
还有另外一种依赖叫做<code>order-only prerequisites</code>，在目标文件存在时，即使这类依赖文件比目标文件新，
目标也不会被当做是过时的，从而make并不会去更新目标文件。</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">target </span><span class="o">:</span> <span class="n">normal</span>-<span class="n">prerequisites</span> <span class="p">|</span> <span class="n">order</span>-<span class="n">only</span>-<span class="n">prerequisites</span>
</code></pre></div>
<p>常规依赖和<code>order-only prerequisites</code>通过管道符号<code>|</code>区分，左侧的是常规依赖，右侧的是<code>order-only prerequisites</code>。
常规依赖可以为空，如果一个依赖同时出现在两种依赖类型中，会被当成常规依赖。</p>

<p>比如，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nv">LIBS</span> <span class="o">=</span> libtest.a
<span class="nf">foo </span><span class="o">:</span> <span class="n">foo</span>.<span class="n">c</span> <span class="p">|</span> <span class="k">$(</span><span class="nv">LIBS</span><span class="k">)</span>
    <span class="k">$(</span>CC<span class="k">)</span> <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="nv">$&lt;</span> -o <span class="nv">$@</span> <span class="k">$(</span>LIBS<span class="k">)</span>
</code></pre></div>
<p>make在执行时，假定foo已存在。如果foo.c被修改，那么将重新生成foo。
如果libtest.a被修改，foo并不会被重新生成。$(LIBS)只有在foo不存在的时候，才参与规则的执行。</p>

<p>另外，<code>$&lt;</code>代表依赖的第一个文件，<code>$@</code>代表目标文件，下面会细细说来。</p>

<h1>通配符的使用</h1>

<p>通过使用通配符，我们可以用一个文件名来表示一类文件。make支持三个通配符<code>*</code>、<code>?</code>、<code>[...]</code>。
这些和Bourne shell中是一样的。此外，文件名以<code>~</code>开头表示当前用户的主目录。</p>

<p>通配符可用在规则的命令中，这时shell会对通配符做通配处理。比如：</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">clean </span><span class="o">:</span> 
    rm -f *.o
</code></pre></div>
<p>通配符还可以用在规则的依赖中，如：</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">print </span><span class="o">:</span> *.<span class="n">c</span>
    lpr -p <span class="nv">$?</span>
    touch print
</code></pre></div>
<p>输入<code>make print</code>指令，它会打印出自从上次打印后有改变的所有c文件。</p>

<p>通配符不能直接用在变量定义上</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nv">objects</span> <span class="o">=</span> *.o
</code></pre></div>
<p>这里的objects的值就是*.o。如果你想在此处使用通配符展开，即让*.o代表当前目录下的所有object文件，
可以这样：</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nv">objects</span> <span class="o">=</span> <span class="k">$(</span>wildcard *.o<span class="k">)</span>
</code></pre></div>
<p>这里使用了wildcard函数，当我们在Makefile的任一处使用<code>$(wildcard pattern...)</code>，
它都会被通配符匹配到的文件名称所替换。</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nv">objects</span> <span class="o">:=</span> <span class="k">$(</span>patsubst %.c, %.o, <span class="k">$(</span>wildcard *.c<span class="k">))</span>

<span class="nf">foo </span><span class="o">:</span> <span class="k">$(</span><span class="nv">objects</span><span class="k">)</span>
    cc -o foo <span class="k">$(</span>objects<span class="k">)</span>
</code></pre></div>
<p>这里先找到当前目录下的所有.c文件，然后替换成.o文件，最后生成foo目标文件。</p>

<h1>文件搜索</h1>

<p>在一些大的工程中，包含大量的源文件，一般我们会把源文件分类，并放在不同的目录中。
所以，当make去找寻文件的依赖关系时，你可以在文件前加上路径，
但更好的方法是你把一个路径告诉make，让make自动去查找。</p>

<h2>VPATH：为所有依赖指定搜索目录</h2>

<p>全局变量VPATH指定了make要去查找的一系列目录。
如果make没有在当前目录找到需要的依赖文件及目标文件，那么make会依次在这些目录中查找。</p>

<p>在VPATH变量中，目录名称间以冒号或者空格符进行分隔（MS-DOS和MS-Windows中以分号作为分隔符，
因为路径名中可能包含冒号）。</p>

<p>比如说，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nv">VPATH</span> <span class="o">=</span> src : ../headers
</code></pre></div>
<p>列出了两个目录src和../headers，make就会按照这个次序进行查找。
假定foo.c放在src目录下，当我们定义了VPATH之后，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">foo.o </span><span class="o">:</span> <span class="n">foo</span>.<span class="n">c</span>
</code></pre></div>
<p>会被解析成这个样子
<code>makefile
foo.o : src/foo.c
</code></p>

<h2>vpath指令</h2>

<p>另一个设置文件搜索路径的方法是关键字<code>vpath</code>，与<code>VPATH</code>不同的是，
它具有模式匹配的功能，可以指定不同的文件在不同的搜索目录中。vpath指令有以下三种形式：</p>

<ol>
<li><p><code>vpath pattern directories</code> 为符合pattern的文件名指定搜索目录directories。
可以包含多个目录，目录间通过冒号（MS-DOS和MS-Windows下以分号）或空格符分隔。</p></li>
<li><p><code>vpath pattern</code> 清除符合pattern的文件的搜索目录。</p></li>
<li><p><code>vpath</code> 清除之前vpath指令设置的搜索目录。</p></li>
</ol>

<p>vpath中的pattern一般需要包含<code>%</code>字符，<code>%</code>字符的意思是匹配零到若干字符。
例如，%.h表示所有以.h结尾的文件（如果没有%，表示完全匹配）。
谨慎使用vpath清除目录指令，你可能一不小心就疏忽了Makefile中的延迟展开。</p>

<p>pattern指定了要搜索的文件集，directories指定要搜索的目录。
比如：</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">vpath %.h ../headers
</code></pre></div>
<p>告诉make在../headers目录下搜索所有以.h结尾的文件（如果该文件在当前目录没有找到）。</p>

<p><strong>注意</strong>：这里的路径仅限于在Makefile文件中出现的.h文件，并不能指定源文件中包含的头文件的路径
（.c源文件中包含的头文件的路径需要通过gcc的<code>-I</code>参数来指定）。</p>

<p>make按照vpath指令出现的次序依次处理，具有相同pattern的多条指令间无任何关联。</p>

<p>比如，</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">vpath %.c foo
vpath %   blish
vpath %.c bar
</code></pre></div>
<p>make会先在foo目录下查找.c文件，然后是blish目录，最后是bar目录。</p>

<p>再或者，</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">vpath %.c foo : bar
vpath %   blish
</code></pre></div>
<p>make会先在foo目录下查找.c文件，然后是bar目录，最后是blish目录。
此外，%会匹配所有类型的文件，因此，make可能会在blish目录查找别的类型的文件。</p>

<h2>在命令行中指定搜索目录</h2>

<p>当make通过文件搜索找到依赖所在的目录时，命令中的同一个依赖并不会被指定在这个目录。
因此，你需要为命令行中的文件指定搜索目录，这样make才能够找到这些文件。</p>

<p><code>$^</code>就是做这个的，它表示所有依赖的集合，包括查找到的目录路径。<code>$@</code>表示目标文件。</p>

<p>于是，Makefile就变成了这个样子（其中变量CFLAGS是C编译参数），</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">foo </span><span class="o">:</span> <span class="n">foo</span>.<span class="n">c</span>
    cc -c <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="nv">$^</span> -o <span class="nv">$@</span>
</code></pre></div>
<p>有些时候，目标文件需要依赖头文件（比如说头文件中定义了全局变量）。
而在命令行中不需要使用这些头文件，这时我们可以使用变量<code>$&lt;</code>，它代表第一个依赖文件。</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nv">VPATH</span> <span class="o">=</span> src : ../headers
<span class="nf">foo.o </span><span class="o">:</span> <span class="n">foo</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">hack</span>.<span class="n">h</span>
    cc -c <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="nv">$&lt;</span> -o <span class="nv">$@</span>
</code></pre></div>
<h2>搜索目录和隐式规则</h2>

<p>make根据隐式规则编译文件时也会自动使用VPATH和vpath指定的搜索目录。</p>

<p>上例的Makefile使用隐式规则后如下，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nv">VPATH</span> <span class="o">=</span> src : ../headers
<span class="nf">foo.o </span><span class="o">:</span> <span class="n">defs</span>.<span class="n">h</span> <span class="n">hack</span>.<span class="n">h</span>
</code></pre></div>
<p>make先在当前目录查找foo.c，如果没找到会去搜索src目录和../headers目录。
找到后根据隐式规则进行编译，编译命令也会使用加上搜索目录后的文件。</p>

<h2>链接库的搜索目录</h2>

<p>Makefile中程序链接的静态库、共享库也可以指定搜索目录。这点和指定头文件的目录很像，
头文件通过-I参数指定，链接库则是以<code>-lname</code>的形式给出。</p>

<p>如存在<code>-lname</code>形式的依赖文件，make会依次在当前目录查找libname.so、libname.a。
如果没有找到，会接着去VPATH和vpath指定的目录查找。然后是目录/lib、/usr/lib和
/prefix/lib（一般是/usr/local/lib）。</p>

<p>比如，/usr/lib目录下有文件libcurses.a，并且不存在文件libcourse.so，那么</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">foo </span><span class="o">:</span> <span class="n">foo</span>.<span class="n">c</span> -<span class="n">lcurses</span>
    cc <span class="nv">$^</span> -o <span class="nv">$@</span>
</code></pre></div>
<p>中的命令会被解释成<code>cc foo.c /usr/lib/libcurses.a -o foo</code>。
这些是通过变量<code>.LIBPATTERNS</code>做的匹配。它的默认值是<code>lib%.so lib%.a</code>，
当依赖形如<code>-lname</code>时，会被匹配成<code>libname.so</code>或者<code>libname.a</code>后做路径搜索。</p>

<h1>伪目标</h1>

<p>伪目标其实是命令行的别名，而不是目标文件的名字。使用伪目标有两个好处：</p>

<ol>
<li>避免与同名文件的冲突</li>
<li>提高性能</li>
</ol>

<p>下面是一个例子，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">clean </span><span class="o">:</span> 
    rm *.o temp
</code></pre></div>
<p>这里的clean就是一个伪目标，因为rm命令并不会创建一个名为clean的文件。</p>

<p>然而这个例子存在一个弊端，就是可能造成与同名文件的冲突。
如果当前目录下存在名为clean的文件，加上clean的依赖为空，clean会被认为最新的，所以不会去执行rm命令。</p>

<p>为了避免这种情况，可以显式的声明clean为伪目标。如下，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">.PHONY </span><span class="o">:</span> <span class="n">clean</span>
<span class="nf">clean </span><span class="o">:</span>
    rm *.o temp
</code></pre></div>
<p>这样，即使当前目录下存在名为clean的文件也不会影响<code>make clean</code>的执行。</p>

<p>伪目标的一个应用场景是make的并行和递归执行。一个简单的实现方式是在命令行中使用shell循环，如下，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nv">SUBDIRS</span> <span class="o">=</span> foo bar baz

<span class="nf">subdirs</span><span class="o">:</span>
    <span class="k">for</span> dir in <span class="k">$(</span>SUBDIRS<span class="k">)</span><span class="p">;</span> <span class="k">do</span> <span class="se">\</span>
        <span class="k">$(</span>MAKE<span class="k">)</span> -C <span class="nv">$$</span>dir<span class="p">;</span> <span class="se">\</span>
        <span class="k">done</span>
</code></pre></div>
<p>但这种方式会带来2个问题：</p>

<ol>
<li>子目录执行make出现失败时，make不会退出。我们很难定位到哪一个目录执行失败。</li>
<li>没有用到make对目录的并行处理功能。</li>
</ol>

<p>通过将子目录设置为伪目标可以解决这些问题，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nv">SUBDIRS</span> <span class="o">=</span> foo bar baz

<span class="nf">.PHONY </span><span class="o">:</span> <span class="n">subdirs</span> <span class="k">$(</span><span class="nv">SUBDIRS</span><span class="k">)</span>

<span class="nf">subdirs </span><span class="o">:</span> <span class="k">$(</span><span class="nv">SUBDIRS</span><span class="k">)</span>

<span class="nf">$(SUBDIRS) </span><span class="o">:</span> 
    <span class="k">$(</span>MAKE<span class="k">)</span> -C <span class="nv">$@</span>

<span class="nf">foo </span><span class="o">:</span> <span class="n">baz</span>
</code></pre></div>
<p>上面的<code>foo : baz</code>规定了子目录的执行顺序，子目录baz完成编译后才会去编译子目录foo。</p>

<p>伪目标不能是真实目标的依赖，如果是这样，更新真实目标或者执行伪目标都会发生不必要的牵连。</p>

<p>伪目标也可以有依赖文件。同样它还可以是默认（最终）目标，只需要把它放在第一个。
设想这样一个场景，在一个目录下包含多个程序。如果你希望一条make指令就能编译所有的程序，
我们可以利用一个伪目标all，并把这些程序设置成它的依赖文件。如下，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">all </span><span class="o">:</span> <span class="n">prog</span>1 <span class="n">prog</span>2 <span class="n">prog</span>3
<span class="nf">.PHONY </span><span class="o">:</span> <span class="n">all</span>

<span class="nf">prog1 </span><span class="o">:</span> <span class="n">prog</span>1.<span class="n">o</span> <span class="n">utils</span>.<span class="n">o</span>
    cc -o prog1 prog1.o utils.o

<span class="nf">prog2 </span><span class="o">:</span> <span class="n">prog</span>2.<span class="n">o</span> 
    cc -o prog2 prog2.o

<span class="nf">prog3 </span><span class="o">:</span> <span class="n">prog</span>3.<span class="n">o</span> <span class="n">sort</span>.<span class="n">o</span> <span class="n">utils</span>.<span class="n">o</span>
    cc -o prog3 prog3.o sort.o utils.o
</code></pre></div>
<p>这时，只需一条make指令，就能编译这三个程序。我们也可以使用<code>make prog1</code>来单独生成prog1。</p>

<p>另外，伪目标也可以是依赖。比如，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">.PHONY </span><span class="o">:</span> <span class="n">cleanall</span> <span class="n">cleanobj</span> <span class="n">cleandiff</span>

<span class="nf">cleanall </span><span class="o">:</span> <span class="n">cleanobj</span> <span class="n">cleandiff</span>
    rm program

<span class="nf">cleanobj </span><span class="o">:</span> 
    rm *.o

<span class="nf">cleandiff </span><span class="o">:</span>
    rm *.diff
</code></pre></div>
<p>这里输入<code>make cleanall</code>就可以删除object files、difference files和program。
同样也可以输入<code>make cleanobj</code>来删除object files。</p>

<p>备注：<code>-rm</code>在缺少删除文件时，不会退出，但会打印错误信息。
<code>rm -f</code>在缺少删除文件时，不会退出，也不会打印错误信息。
因而可以在Makefile中定义变量<code>RM = rm -f</code>，然后使用<code>$(RM)</code>来代替rm。</p>

<h1>没有命令或依赖的规则</h1>

<p>先来看一个例子，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">clean </span><span class="o">:</span> <span class="n">FORCE</span>
    rm <span class="k">$(</span>objects<span class="k">)</span>
<span class="nf">FORCE </span><span class="o">:</span>
</code></pre></div>
<p>例子中<code>FORCE</code>和伪目标中<code>.PHONY : clean</code>的作用是相同的。它符合如下条件：</p>

<p>如果一条规则中没有命令或者依赖，并且目标是一个并不存在的文件时，
make在执行这条规则时，总认为该目标是最新的。那么依赖该目标的文件，它的命令行每次都会被执行。</p>

<p>实际上，使用<code>.PHONY</code>更加清晰且效率更高，但有些版本的make并不支持伪目标，这时就得使用<code>FORCE</code>了。</p>

<h1>空目标文件</h1>

<p>上面我们有提到这样一个例子，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">print </span><span class="o">:</span> <span class="n">foo</span>.<span class="n">c</span> <span class="n">bar</span>.<span class="n">c</span>
    lpr -p <span class="nv">$?</span>
    touch print
</code></pre></div>
<p>print就是一个空目标文件，它通常只有这一个作用——记录事件。本例中是用来记录自从上次打印后foo.c和bar.c中有变动的文件。
print可以不存在或者为空，主要用来记录时间戳。一旦foo.c或者bar.c发生改变后，我们就会把发生改变的文件打印出来，然后重新创建print文件。
<code>$?</code>用来打印发生改动的文件。</p>

<h1>多目标</h1>

<p>Makefile的规则支持多目标，一条多目标规则相当于多条单目标规则。
自动化变量<code>$@</code>的使用可以帮助规则中的命令适用于所有的目标。多目标一般用于以下两种情况，</p>

<ol>
<li><p>规则中只描述了依赖关系，并没有定义命令。如：
<code>makefile
kbd.o command.o files.o : command.h
</code>
这条makefile给3个目标文件增加了一个依赖。</p></li>
<li><p>相似的命令行作用于所有的目标。重新生成目标的命令行并不需要完全相同，可以通过<code>$@</code>来引用具体的目标。</p></li>
</ol>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">bigoutput littleoutput </span><span class="o">:</span> <span class="n">test</span>.<span class="n">g</span>
    generate text.g -<span class="k">$(</span>subst output,,<span class="nv">$@</span><span class="k">)</span> &gt; <span class="nv">$@</span>
</code></pre></div>
<p>等价于</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">bigoutput </span><span class="o">:</span> <span class="n">test</span>.<span class="n">g</span>
    generate test.g -big &gt; bigoutput
<span class="nf">littleoutput </span><span class="o">:</span> <span class="n">test</span>.<span class="n">g</span>
    generate test.g -little &gt; littleoutput
</code></pre></div>
<p>例子中generate根据命令行参数决定输出文件的类型。</p>

<h1>静态模式</h1>

<p>静态模式可以更加容易的定义多目标规则。它可以根据目标的名字来构造出依赖文件的名字。
依赖名字不必完全相同，但需要是相似的。</p>

<p>如下，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">targets ... </span><span class="o">:</span> <span class="n">target</span>-<span class="n">pattern</span> : <span class="n">prereq</span>-<span class="n">patterns</span> ...
    recipe
    ...
</code></pre></div>
<p>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。
target-pattern和prereq-patterns说明了如何通过目标文件生成依赖文件。</p>

<p>target-pattern定义了targets的模式。</p>

<p>prereq-patterns定义了目标的依赖模式。它对target-parttern形成的模式再进行一次依赖目标的定义。</p>

<p>看这样一个例子，它通过foo.c、bar.c编译foo.o和bar.o。</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nv">objects</span> <span class="o">=</span> foo.o bar.o

<span class="nf">all </span><span class="o">:</span> <span class="k">$(</span><span class="nv">objects</span><span class="k">)</span>

<span class="nf">$(objects) </span><span class="o">:</span> %.<span class="n">o</span> : %.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="nv">$&lt;</span> -o <span class="nv">$@</span>
</code></pre></div>
<p>例子中，指明了我们的目标从<code>$objects</code>中获取，%.o代表所有以.o结尾的目标，也就是foo.o和bar.o，
也就是变量<code>$objects</code>集合的模式，而依赖模式%.c取模式%.o中的%，也就是foo和bar，并为其加上后缀.c，
于是我们的依赖目标就是foo.c和bar.c。</p>

<p>于是，上面的规则展开后等价于下面的规则。</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">foo.o </span><span class="o">:</span> <span class="n">foo</span>.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>CFLAGS<span class="k">)</span> foo.c -o foo.o
<span class="nf">bar.o </span><span class="o">:</span> <span class="n">bar</span>.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>CFLAGS<span class="k">)</span> bar.c -o bar.o
</code></pre></div>
<p>所有的目标都要符合target-pattern才行，如果存在target不符合target-pattern，make会报warning。
如果存在一长串文件，其中只有一些是符合pattern的，我们可以通过使用filter函数来移除不相符的文件。</p>

<p>比如，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nv">files</span> <span class="o">=</span> foo.elc bar.o lose.o

<span class="nf">$(filter %.o, $(files))</span><span class="o">:</span> %.<span class="n">o</span>: %.<span class="n">c</span>
    <span class="k">$(</span>CC<span class="k">)</span> -c <span class="k">$(</span>CFLAGS<span class="k">)</span> <span class="nv">$&lt;</span> -o <span class="nv">$@</span>
<span class="nf">$(filter %.elc, $(files)) </span><span class="o">:</span> %.<span class="n">elc</span>: %.<span class="n">el</span>
    emacs -f batch-byte-compile <span class="nv">$&lt;</span>
</code></pre></div>
<p>其中<code>$(filter %.o, $(files))</code>的结果是过滤出.o文件，得到bar.o和lose.o。</p>

<p>下面这个例子展示了静态模式规则中<code>$*</code>的使用，<code>$*</code>就是%匹配的结果，比如上例的foo和bar。</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">bigoutput littleoutput </span><span class="o">:</span> %<span class="n">output</span> : <span class="n">text</span>.<span class="n">g</span>
    generate text.g -<span class="nv">$*</span> &gt; <span class="nv">$@</span>
</code></pre></div>
<p>其中<code>$*</code>表示big和little。</p>

<h1>自动生成依赖</h1>

<p>在Makefile中，我们的依赖关系中可能包含一系列的头文件，比如在main.c中通过<code>#include</code>包含了defs.h，
那么我们的依赖关系是，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">main.o </span><span class="o">:</span> <span class="n">defs</span>.<span class="n">h</span>
</code></pre></div>
<p>这样，每次defs.h发生改变时，make就会重新生成main.o。如果是一个比较大的工程，你必须清楚哪些C文件包含了哪些头文件，
并且，你要在加入或者删除头文件的时候也要小心翼翼的修改Makefile。为了避免这个麻烦，可以使用C/C++编译器一个功能。
通过支持<code>-M</code>选项，编译器会帮助你在源文件中查找<code>#include</code>行，从而自动生成依赖关系。</p>

<p>比如，</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">cc -M main.c
</code></pre></div>
<p>其输出是，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">main.o </span><span class="o">:</span> <span class="n">main</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span>
</code></pre></div>
<p>这样你就不用手动写这些依赖关系了，编译器会帮你做这些。
此外，如果在main.c中包含了标准库的头文件，<code>-M</code>选项会把标准库头文件的依赖描述也包含在内。
如不需要在依赖关系中考虑标准库头文件，可使用<code>-MM</code>参数。</p>

<p>那么编译器的这个功能如何与我们的Makefile联系在一起呢？GNU建议把为每个源文件生成的依赖关系放在一个文件中，
即为每一个<code>name.c</code>生成一个<code>name.d</code>的Makefile文件，其中<code>name.d</code>列出了<code>name.o</code>的依赖。
于是，我们可以写出.c文件和.d文件的依赖关系，让make自动生成或更新.d文件，并把其包含在主Makefile文件中，
这样，就可以自动化生成每个文件的依赖关系了。</p>

<p>下面给出一个模式规则来产生.d文件，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">%.d </span><span class="o">:</span> %.<span class="n">c</span>
    @set -e<span class="p">;</span> rm -f <span class="nv">$@</span><span class="p">;</span> <span class="se">\</span>
    <span class="k">$(</span>CC<span class="k">)</span> -M <span class="k">$(</span>CPPFLAGS<span class="k">)</span> <span class="nv">$&lt;</span> &gt; <span class="nv">$@</span>.<span class="nv">$$$$</span><span class="p">;</span> <span class="se">\</span>
    sed <span class="s1">&#39;s,\($*\)\.o[ :]*,\1.o $@ : ,g&#39;</span> &lt; <span class="nv">$@</span>.<span class="nv">$$$$</span> &gt; <span class="nv">$@</span><span class="p">;</span> <span class="se">\</span>
    rm -f <span class="nv">$@</span>.<span class="nv">$$$$</span>
</code></pre></div>
<p>此规则的含义是所有的.d文件依赖同名的.c文件。
<code>-e</code>参数表示，如果$(CC)命令执行失败，shell立即退出执行。
如果不希望依赖标准库头文件可用<code>-MM</code>参数来代替<code>-M</code>。
第二行的意思是，为每一个<code>$&lt;</code>即.c文件，生成依赖关系，并放在一个临时文件里，<code>$$$$</code>表示当前进程号。
第三行使用sed命令做了一个替换。第四行是删除临时文件。</p>

<p>总而言之，这个模式要做的事情就是在编译器生成的依赖关系中加入.d文件的依赖，即把依赖关系</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">main.o </span><span class="o">:</span> <span class="n">main</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span>
</code></pre></div>
<p>转成</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nf">main.o main.d </span><span class="o">:</span> <span class="n">main</span>.<span class="n">c</span> <span class="n">defs</span>.<span class="n">h</span>
</code></pre></div>
<p>于是，我们的.d文件也自动更新了，并能自动生成，当然，你还可在这个.d文件中加入生成命令，
让每个.d文件都包含一个完整的规则。一旦完成这个工作，我们就可以接着把这些自动生成的规则放到
我们的主Makefile中。可以使用Makefile的include命令，来引入别的Makefile文件。</p>

<p>如，</p>
<div class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nv">sources</span> <span class="o">=</span> foo.c bar.c
<span class="cp">include $(sources:.c=.d)</span>
</code></pre></div>
<p>上述语句中的<code>$(sources:.c=.d)</code>中的<code>.c=.d</code>是做一个替换，把变量$(sources)中的所有.c字符串替换为.d。
当然你得注意次序，因为include是按次载入文件，最先载入的.d文件中的目标会成为最终目标。</p>

<p>参考：
<a href="https://www.gnu.org/software/make/manual/make.pdf">GNU Make</a>
<a href="http://blog.csdn.net/haoel/article/details/2886">跟我一起写Makefile</a></p>

      <div class="copyright">
        <hr/>
        <p>
          除非注明，本博客文章均为原创，转载请以链接形式标明本文地址：
          <a href="/2015/12/26/makefile-3.html">http://terminalworld.github.io/2015/12/26/makefile-3.html</a>
        </p>
      </div>
    </div>

    <ul class="pager" style="margin: 30px 0 0">
    
    <li class="previous">
        <a data-toggle="tooltip" data-placement="right" title="二、书写Makefile" href="/2015/12/25/makefile-2.html">&larr; 上一篇</a>
    </li>
    
    
    <li class="next">
        <a data-toggle="tooltip" data-placement="left" title="Item 1：视C++为一个语言联邦" href="/2015/12/29/effective-1.html">下一篇 &rarr;</a>
    </li>
    
</ul>


    <!--<hr style="margin: 20px 0;"/>


<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'harttleland'; 
  $(function () {
      var dsq = document.createElement('script');
      dsq.type = 'text/javascript';
      dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  });
</script>
<noscript>请 <a href="http://disqus.com/?ref_noscript">启用 JavaScript</a> 来查看评论 </noscript>
-->
  </div>
</div>

<script>
  $(function () {
    var toc = getTOC($('.post-display .right'));
    if (toc != null) {
      $('.sidebar').append(toc);

      //sidebar affix, this offset is for sidebar position recognition
      setTimeout(function () {
        var $sideBar = $('.sidebar');
        $sideBar.affix({
          offset: {
            top: function () {
              var offsetTop = $sideBar.offset().top;
              return (this.top = offsetTop - 20);
            },
            bottom: function () {
              return (this.bottom = $(document).height() - $('.md').offset().top - $('.md').height());
            }
          }
        });
      }, 100);

      //sidebar scroll spy
      $('body').scrollspy({
        target: '.sidebar',
        offset: 10  //make sure to spy the element when scrolled to
      });
    }
    else {
      $('.post-display .right')
          .removeClass('col-lg-10 col-md-9 col-sm-8')
          .addClass('col-md-12');
      $('.post-display').removeClass('row-fluid');
      $('.post-display .left').remove();
    }

    $(window).resize(function () {
      $('body').scrollspy('refresh');
    });

  });

  //生成目录
  function getTOC($content) {
    var $toc = $('<ul class="nav level-0" >').addClass("nav sidenav");

    var base_level = 1;
    while ($content.find('h' + base_level).length < 1 && base_level < 7) base_level += 1;
    if (base_level == 7) return null;

    $content.find(':header').each(function (i) {
      var $this = $(this);
      $this.attr('id', i);

      var level = parseInt(this.nodeName.substr(1));
      var offset = level - base_level;

      var li = new $('<li/>')
          .append('<a href="#' + i + '" class="animate">' + $this.text() + '</a>')
          .append($('<ul class="nav level-' + (offset + 1) + '"/>'));

      $('<div>').append($toc).find('ul.level-' + offset + ':last').append(li);
    });
    // remove empty ul
    $toc.find('ul').not(':parent').remove();
    return $toc;
  }
</script>

<!-- latex render begin -->
<script type="text/x-mathjax-config">  
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$', '$'] ],
            displayMath: [ ['$$', '$$'], ['$$$', '$$$']],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    });
    MathJax.Hub.Queue(function () {
        $('body').scrollspy('refresh'); 
    });
</script>

<script async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
<!-- latex render end -->



  </div>
</div>


  </div>
</div>

<!--

<div id="footer">
  <div class="container-fluid">
    <div class="credit nowrap">
      <p class="text-muted" title="Copyright © 2013 Harttle. Hosted by GitHub and powered by Jekyll.">
        Copyright © 2013
        <a href="//harttle.github.io">Harttle</a>. Hosted by
        <a href="//github.com/" target="_blank">GitHub</a>
        and powered by
        <a href="//jekyllrb.com/">Jekyll</a>.
      </p>
      <span class="pull-right hidden-xs follow">
        <a href="https://www.facebook.com/harttle" target="_blank"> <i class="fa fa-facebook-square fa-lg"></i>
        </a>
        <a href="http://www.linkedin.com/profile/view?id=294339963" target="_blank"> <i
            class="fa fa-linkedin-square fa-lg"></i> </a>
        <a href="https://plus.google.com/113657098095399233141?rel=author" target="_blank"> <i
            class="fa fa-google-plus-square fa-lg"></i> </a>
        <a href="//github.com/harttle/harttle.github.io" target="_blank"> <i class="fa fa-github fa-lg"></i>
        </a>
        <a href="/feed.xml" target="_blank"> <i class="fa fa-rss-square fa-lg"></i> </a>
      </span>

    </div>
  </div>
</div>

-->

<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
<script src="//oss.maxcdn.com/libs/html5shiv/3.6.2/html5shiv.js"></script>
<script src="//v3.bootcss.com/docs-assets/js/respond.min.js"></script>
<![endif]-->
<script src="/assets/lib/jquery/jquery.scrollUp.min.js"></script>
<script src="/assets/lib/jquery/jquery.lazyload.min.js" type="text/javascript"></script>
<script src="/assets/lib/bootstrap/3.2.0/js/bootstrap.min.js"></script>
<script src="/assets/lib/jQCloud/jqcloud.min.js"></script>


<script>
  var footHeight = $('#footer').outerHeight(true);
  $(function () {
    

      //激活工具提示
      $('[data-toggle="tooltip"]').tooltip();

      //图片延迟加载
      $("img.lazy").lazyload({effect: "fadeIn", skip_invisible: false});	//bootstrap thumbnail img will be invisible at the begining

      //回到顶部按钮
      $.scrollUp({
        scrollName: 'scrollUp', topDistance: '300', topSpeed: 300, animation: 'fade', animationInSpeed: 500,
        animationOutSpeed: 500, scrollText: '', activeOverlay: false,
      });

      //页面内链接滑动效果
      $body = (window.opera) ? (document.compatMode == "CSS1Compat" ? $('html') : $('body')) : $('html,body');
      $('a.animate').click(function () {
        if ($(this).attr('offset')) {
          offset += parseInt($(this).attr('offset'));
        }
        $body.animate({scrollTop: $($(this).attr('href')).offset().top}, 500);
        return false;
      });
    });
</script>

</body>
</html>
