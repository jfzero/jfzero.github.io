---
layout: blog
categories: C++
title: Item 19：设计类犹如设计类型
subtitle: Effective C++ 读书笔记
tags: C++
excerpt: 设计类犹如设计类型
---

> Treat class design as type design

设计类应当像设计内置类型一样谨慎，需全面仔细的考虑如下问题，

* 新对象该怎样被创建和销毁？包括构造函数和析构函数、内存分配函数和内存释放函数(`operator new`、`operator new[]`、`operator delete`和`operator delete[]`)。
* 对象初始化和对象赋值之间有什么区别？这对应着不同的函数调用（见[Item 4](/2016/01/20/effective-4.html)）。
* 通过pass-by-value使用新对象时，意味着什么？这由拷贝构造函数决定。
* 新类型的合法值是多少？该取值范围决定着成员函数（构造函数、赋值函数、setter函数）中应当进行的错误检查工作，同时也影响着这些函数抛出的异常。
* 新类型是否适合一继承体系？继承或是被继承，都应考虑各个函数--特别是析构函数是否是虚函数。
* 新类型是否支持类型转换？比如，允许类型T1可隐式转换为T2，需要在class
  T1内写类型转换函数（operator T2）或在class 
  T2内写一个单参数调用的非显式构造函数。若只允许显式构造函数，就得写专门负责转换的函数（见[Item 15](/2016/02/03/effective-15.html)）。
* 哪些操作符和函数对新类型来说是有意义的？这决定着你需要定义哪些函数。
* 哪些函数需要被封装起来？即声明为private。
* 谁该使用新类型的成员函数？这个问题有助于决定哪些成员是public、哪些是protected、哪些是private，它还有助于你决定哪些类和函数是friends，以及将该类嵌套于另一个类是否合理。
* 什么是新类型的未声明接口？它对效率、异常安全以及资源使用（比如锁和动态分配内存）提供何种保证？ 
* 新类型是否足够一般化？或许你需要定义的是一个class template。
* 真的需要定义一个类型吗？如果只是定义一个派生类以便为现有基类添加功能，定义非成员函数或模板也许更适合达到目标。

这些问题其实都不太好回答，但如果能够设计出像C++内置类型一样优秀的用户自定义类型，这些辛苦也是值得的。毕竟艰难困苦，玉汝于成！
